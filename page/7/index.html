<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="不积跬步无以至千里">
<meta property="og:type" content="website">
<meta property="og:title" content="雷哥的博客">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="雷哥的博客">
<meta property="og:description" content="不积跬步无以至千里">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雷哥的博客">
<meta name="twitter:description" content="不积跬步无以至千里">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '雷哥'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/">





  <title>雷哥的博客</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雷哥的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/dl/第二门课-第二周/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/dl/第二门课-第二周/" itemprop="url">第二门课-第二周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T22:40:03+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/吴恩达课程总结/" itemprop="url" rel="index">
                    <span itemprop="name">吴恩达课程总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h3><p>第二周主要学习如何优化算法，优化算法能够让你快速训练模型，主要分三类：</p>
<ul>
<li>Mini-batch</li>
<li>指数加权平均(Momentum，RMSprop，Adam)</li>
<li>学习率衰减</li>
</ul>
<h4 id="2-1-Mini-batch梯度下降-amp-理解"><a href="#2-1-Mini-batch梯度下降-amp-理解" class="headerlink" title="2.1 Mini-batch梯度下降&amp;理解"></a>2.1 Mini-batch梯度下降&amp;理解</h4><ul>
<li>迭代中的cost一定是逐渐减小</li>
<li>三种梯度下降方法(Batch，随机梯度，Mini-Batch)，cost图如下： <ul>
<li>蓝色为常用Batch方式，梯度不会抖动，缺点是每次迭代是全部样本比较慢，一次迭代只改变一次梯度</li>
<li>紫色为随机梯度，每次一个样本，这种方式cost的计算抖动比较大，在最优点附近也是抖动，并不会停留在此</li>
<li>绿色为Mini-batch方式： <ul>
<li>也会出现抖动，因为Cost的计算是随意加入的样本，而每次epom样本都在变化。</li>
<li>它也不一定会在很小范围内收敛或者波动，这种情况就可以考虑减小学习率了</li>
<li>Mini-batch size选择，一般选择2n，64–512比较常见</li>
</ul>
</li>
<li>三种方式如何选择，主要还是看样本量，一般随机梯度不会选，如果样本量\&lt;2000，选择Batch，否则选择Mini-batch<img src="/2018/09/10/dl/第二门课-第二周/resources/3BC2DF36EFE921C9C0EEB02EBBEB579D">
</li>
</ul>
</li>
</ul>
<h4 id="2-3-指数加权平均数-amp-理解"><a href="#2-3-指数加权平均数-amp-理解" class="headerlink" title="2.3 指数加权平均数 &amp; 理解"></a>2.3 指数加权平均数 &amp; 理解</h4><ul>
<li>也叫做移动平均值，就是计算局部范围的平均值：$v_t=\beta v_{t-1}+(1-\beta)\theta_{t-1}$(公式1),其中$\frac 1{(1-\beta)}$代表的所要计算的平均范围(这结论数学推导可查阅资料)，比如计算温度的指数加权平均&gt;值 $\theta=0.9$,那么$\frac 1{(1-\beta)}=10$,表示计算的10的平均温度</li>
</ul>
<h4 id="2-5-指数加权平均的偏差修正"><a href="#2-5-指数加权平均的偏差修正" class="headerlink" title="2.5 指数加权平均的偏差修正"></a>2.5 指数加权平均的偏差修正</h4><ul>
<li><p><strong>蓝色</strong>是没有添加指数加权平均的各个离散点，<strong>红色</strong>为$\beta=0.9$的加权平均值曲线，<strong>绿色</strong>为$\beta=0.98$加权平均值曲线，<strong>紫色</strong>为$\beta=0.98$并且进行修正后的加权平均值曲线</p>
<img src="/2018/09/10/dl/第二门课-第二周/resources/BE291D0E3476361A7A64454978286DA9">
</li>
<li><p>上图可以看见绿色和紫色的区别是在初始阶段，通过公式(1)计算得到的$v_0,v_1$和实际值差别是比较大的，造成了前面几个数不太准确,方法：使用$\frac{v_t}{1-\beta_t}$而不是直接用$v_t$进行评估,可以看见初期比较准确，然后后期$\beta_t$很小,所以$\frac{v_t}{1-\beta_t}\approx{v_t}$</p>
</li>
</ul>
<h4 id="2-6-动态梯度下降"><a href="#2-6-动态梯度下降" class="headerlink" title="2.6 动态梯度下降"></a>2.6 动态梯度下降</h4><ul>
<li><strong>目的</strong>：想让在x方向上梯度变化大一点，但是在纵轴方向，来回抖动，想要修正y方向上的抖动。<strong>方案</strong>：在x，y轴分别使用2.5中的指数加权平均法，对y轴的<strong>正负抖动进行抵扣平均</strong>，达到y轴抖动较小目的:<br>$v_{dw}=\beta v_{dw-1}+(1-\beta)d_{dw-1}$<br>W=W-$\alpha v_{dw}$<br>$v_{db}=\beta v_{db-1}+(1-\beta)d_{db-1}$<br>b=b-$\alpha v_{db}$<img src="/2018/09/10/dl/第二门课-第二周/resources/B75553739F2911D13CCF981D2AC5D707"></li>
<li>假设W，b分别表示x，y轴。看下面计算公式，其中学习率$\alpha$也是有影响的，会在下面介绍<img src="/2018/09/10/dl/第二门课-第二周/resources/DBAC055D9744073F23A30ECC596CA307">
</li>
</ul>
<h4 id="2-7-RMSprop"><a href="#2-7-RMSprop" class="headerlink" title="2.7 RMSprop"></a>2.7 RMSprop</h4><ul>
<li>RMSprop是微分平方加权平均:<br>$S_{dw}=\beta S_{dw-1}+(1-\beta)d_{dw-1}^2$  <strong>1式</strong><br>W=W-$\alpha \frac{dw}{\sqrt S_{dw} + \epsilon}$ <strong>2式</strong>($\epsilon$避免非0,一般$10^{-8}$)<br>$v_{db}=\beta v_{db-1}+(1-\beta)d_{db-1}^2$<br>和动态梯度下降区别：<ul>
<li>并不是正负抵消，这些计算的是微分平方加权平均，然后计算梯度变化的时候除以平方根</li>
<li>原理<strong>(我理解就是将大值调小，小值调大)</strong>：<ul>
<li>如果dw大，那么1式结果$S_{dw}$也会比较大，但2式结果W就会小</li>
<li>如果dw小，那么1式结果$S_{dw}$也会比较小，但2式结果W就会大</li>
</ul>
</li>
</ul>
</li>
<li>RMSprop我理解就是将大值调小，小值调大,个人觉得Momentum(平均后正负抵消)更有效<img src="/2018/09/10/dl/第二门课-第二周/resources/F8B3F5FAEE78DF176AD2D9D1EA759F73">
</li>
</ul>
<h4 id="2-8-Adam优化算法"><a href="#2-8-Adam优化算法" class="headerlink" title="2.8 Adam优化算法"></a>2.8 Adam优化算法</h4><ul>
<li>Momentum与RMSprop的结合</li>
<li>其中有多个超参数及默认值α,β1​(0.9),β2​(0.98),ϵ(10−8)<img src="/2018/09/10/dl/第二门课-第二周/resources/01107664832D4483D8213338204FC312">
</li>
</ul>
<h4 id="2-9-学习率衰减"><a href="#2-9-学习率衰减" class="headerlink" title="2.9 学习率衰减"></a>2.9 学习率衰减</h4><ul>
<li>如果学习率α一直是一个值，在使用Mini-batch方法的时候，就会在收敛值附件波动，根本原因就是在收敛期α过大，变化过多的原因</li>
<li>动态变化α值，开始α希望较大，收敛时α逐渐变小，类似于绿色曲线，在收敛值较小范围波动</li>
</ul>
<img src="/2018/09/10/dl/第二门课-第二周/resources/9E1821378657CB076651F5DC38160B3C">
<h4 id="2-10-局部最优问题"><a href="#2-10-局部最优问题" class="headerlink" title="2.10 局部最优问题"></a>2.10 局部最优问题</h4><ul>
<li>担忧深度学习优化算法总是困在极差的局部最优</li>
<li>通常梯度为0的点并不是局部最优点，实际上成本函数的零梯度点，即鞍点<img src="/2018/09/10/dl/第二门课-第二周/resources/68F0C0CA5B07EF344E68284131BA8147"></li>
<li>普通优化算法一般都是沿着蓝色点坡度向下，比较难走出平稳期。为什么Momentum，RMSprop和Adam能尽早往下坡出平稳期？<img src="/2018/09/10/dl/第二门课-第二周/resources/FA0191259C4FB3E25C573FEA9CF7DEDF">
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/01/dl/第二门课-第一周/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/01/dl/第二门课-第一周/" itemprop="url">第二门课-第一周</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-01T22:49:03+08:00">
                2018-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/吴恩达课程总结/" itemprop="url" rel="index">
                    <span itemprop="name">吴恩达课程总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h3><h4 id="1-1-训练-验证-测试集"><a href="#1-1-训练-验证-测试集" class="headerlink" title="1.1 训练,验证,测试集"></a>1.1 训练,验证,测试集</h4><p>1.训练,验证,测试集 数据一定需要同分布<br> 2.训练,验证,测试集 能够更好的衡量偏差和方差</p>
<h4 id="1-2-amp-1-3-偏差-方差-Bias-Variance"><a href="#1-2-amp-1-3-偏差-方差-Bias-Variance" class="headerlink" title="1.2&amp;1.3 偏差,方差(Bias/Variance)"></a>1.2&amp;1.3 偏差,方差(Bias/Variance)</h4><p>1.偏差,方差最终的值都是基于人眼的,如果人眼误差也比较高的话,那么训练测试误差比较高也比较正常<br> 2.训练集,测试集数据来自同分布<br> 3.高方差可以解释为：拟合了数据集中的错误样本和中间的一些活跃数据<br> 4.首先看偏差，偏差可以接受后，然后评估下验证集的性能来评估方差<br> 5.一般可以根据训练，测试cost曲线来判断高偏差或者高方差,具体可以参考我<a href="https://github.com/yuancl/ml-algorithm/tree/master/exe5-Regularized-LinearR-and-Bias-Variance" target="_blank" rel="noopener">github:正则化以及偏差方差检测</a></p>
<h4 id="1-4-amp-1-5-正则化"><a href="#1-4-amp-1-5-正则化" class="headerlink" title="1.4&amp;1.5 正则化"></a>1.4&amp;1.5 正则化</h4><p>1.解决高方差一般有两种方法：一个是正则化，另外是准备更多的数据<br> 2.L2正则化有时候也称为”权重衰减”，因为在用梯度下降计算参数的时候会在前面乘以小于1的数值<br> 3.疑问：为什么很少使用L2做正则化<br> 3.为什么能防止过拟合？(过拟合的本质就是参数过多，参数过大，维数过高)</p>
<ul>
<li>a.直观上理解当lambda足够大的时候，权重矩阵w接近于0，就把很多隐藏单元给消除了一样</li>
<li>b.sigmoid,tanh激活函数的曲线可以发现，当x值在0附件的时候，曲线接近于直线，呈现直线的性质，并不是非直线</li>
</ul>
<h4 id="1-6-amp-1-7-正则化-Dropout"><a href="#1-6-amp-1-7-正则化-Dropout" class="headerlink" title="1.6&amp;1.7 正则化(Dropout)"></a>1.6&amp;1.7 正则化(Dropout)</h4><p>1.为了不影响Z[4]的期望值，我们需要用Z[4]a[3]/0.8来修正或弥补我们所需要的那20%<br> 2.在测试阶段不能用dropout，因为我们不需要在测试阶段结果是随机的<br> 3.直观理解Dropout和L2正则比较像<br> 4.不能只依赖任何一个特征，因为都有可能被删除<br> 5.根据过拟合的程度设置keep-prob的值，比如W[1]：7x3，W[2]：7x7,W[3]：7x3,所以W[2]层参数最多，可以设置keep-prob稍小一些，比如0.7，第一层可以设置为1，第一层不应该dropout。<br> 6.过拟合才用Dropout方法，CV上通常没有足够多的数据，所以经常会用到<br> 7.Dropout<strong>缺点</strong>：使代价函数J不再被明确定义，个人理解因为中间的神经元不确定是否被dropout，所以每次都神经元个数什么的都不一样</p>
<h4 id="1-8-其他正则化方法"><a href="#1-8-其他正则化方法" class="headerlink" title="1.8 其他正则化方法"></a>1.8 其他正则化方法</h4><p>1.数据扩展(通过旋转，缩放，裁剪等)<br> 2.early stoping</p>
<ul>
<li><strong>为什么能工作：</strong> 因为随机初始的w值都是比较小的，在刚开始训练的时候也不会很大，在后面迭代次数多的时候，w值就会比较大了，这就会使Loss比较大，这个时候stoping是比较好的</li>
<li><strong>缺点:</strong> 如果提早停止了梯度下降，也就停止了J的继续优化，不能得到更小的代价函数J</li>
<li><strong>与正则化lambda比较:</strong> lambda会尝试多轮的值，进行选择</li>
</ul>
<h4 id="1-9-归一化输入"><a href="#1-9-归一化输入" class="headerlink" title="1.9 归一化输入"></a>1.9 归一化输入</h4><p>1.标准化:零均值，归一化方差<br> 2.为什么能归一化效果更好</p>
<ul>
<li><strong>a.从Loss效果图分析：</strong> 归一化后数据更均匀，可以从任何一点入手进行GD迭代，否则曲线就比较凌乱<br><img src="resources/C9C7B619F7FAA0D0649EA455EA4710A8" alt=""></li>
<li><strong>b.从sigmoid或者tanh的曲线图分析：</strong> 归一化后区间在0附件的时候，梯度变化最大的<br><img src="resources/9273406DEF474A8262863E9EDDD8598F" alt=""></li>
</ul>
<p>3.<strong>不用Normalize：</strong> 如果数据本身就处于相似范围，比如已经是1–2，或者0–1，区别不大：1–100</p>
<h4 id="1-10-梯度消失或爆炸"><a href="#1-10-梯度消失或爆炸" class="headerlink" title="1.10 梯度消失或爆炸"></a>1.10 梯度消失或爆炸</h4><p>1.这里只讨论了激活函数的指数级数增长或下降，但它也适用于L相关的导数或者梯度问题，比如另一篇文章<a href="https://app.yinxiang.com/shard/s48/nl/12303615/fbbe860b-d780-4ea0-86e2-b3281095f018/" target="_blank" rel="noopener">梯度问题</a>就是讨论的梯度指数问题<br> <img src="resources/A6E21F3566635A3FFFFD3E6CFF2F3A9E" alt=""></p>
<p>2.见另一篇<a href="https://app.yinxiang.com/shard/s48/nl/12303615/fbbe860b-d780-4ea0-86e2-b3281095f018/" target="_blank" rel="noopener">梯度问题</a></p>
<h4 id="1-11-神经网络权重初始化"><a href="#1-11-神经网络权重初始化" class="headerlink" title="1.11 神经网络权重初始化"></a>1.11 神经网络权重初始化</h4><p>见权重初始化练习：<a href="https://github.com/yuancl/dl-algorithm/blob/master/2-ImprovingDeepNeuralNetworks/Week1/1.Initialization.ipynb" target="_blank" rel="noopener">Initialization</a><br> <img src="resources/3FA08AC1BC944F534A96C4DD711D4E86" alt=""></p>
<p>In general, initializing all the weights to zero results in the network failing to break symmetry. This means that every neuron in each layer will learn the same thing<br> 初始化参数全部为0的时候，每一层的梯度变化的一样的，有就是每一层学习到的是一样的，就不会有比较好的结果</p>
<p>The cost starts very high. This is because with large random-valued weights, the last activation (sigmoid) outputs results that are very close to 0 or 1 for some examples, and when it gets that example wrong it incurs a very high loss for that example. Indeed, when log(a[3])=log(0)log⁡(a[3])=log⁡(0) , the loss goes to infinity.<br> Poor initialization can lead to vanishing/exploding gradients, which also slows down the optimization algorithm.<br> If you train this network longer you will see better results, but initializing with overly large random numbers slows down the optimization.<br> 当随机初始值比较大的时候，最后的输出sigmoid就是0或者1，这个时候如果碰见是0，那么计算lost的时候log(0)就是无限大，所以第一次迭代 Cost after iteration 0: inf<br> 初始化参数过大会使开始训练的时候梯度下降得比较慢，Loss比较大，迭代会比较慢，当然最后也会收敛</p>
<p>Different initializations lead to different results<br> Random initialization is used to break symmetry and make sure different hidden units can learn different things<br> Don’t intialize to values that are too large<br> He initialization works well for networks with ReLU activations.</p>
<h4 id="1-12-amp-1-13-梯度的数值逼近及注意项"><a href="#1-12-amp-1-13-梯度的数值逼近及注意项" class="headerlink" title="1.12&amp;1.13 梯度的数值逼近及注意项"></a>1.12&amp;1.13 梯度的数值逼近及注意项</h4><p>1.双边误差比单边误差小<br> 2.误差值如果小于10−7是比较安全的，如果大于10−5就需要多注意下，如果大于10−3那么应该是有bug<br> 3.如果J包含了正则项，那么求梯度D的时候也一定要包含正则项，感觉这个不用担心，因为有正则项的J，用数学公式求梯度函数一定会有正则项<br> 4.Dropout和梯度逼近不能同时使用，个人理解是因为梯度逼近是对最终的<strong>真实</strong>的J做的梯度逼近，而Dropout国产中个的J′去掉了多个神经元并不是真实的J<br> 5.参考<a href="https://github.com/yuancl/ml-algorithm/blob/master/exe4-NeuralNetwork/nn_cost_fun.py" target="_blank" rel="noopener">NeuralNetwork</a>中的梯度的数值逼近计算</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/ml/聚类/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/ml/聚类/" itemprop="url">聚类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T07:15:20+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/机器学习基础/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="聚类任务"><a href="#聚类任务" class="headerlink" title="聚类任务"></a>聚类任务</h4><ul>
<li>在无监督学习中（unsupervised learning）中，训练样本的标记信息是未知的，目标是通过对无标记的训练样本的学习来揭示数据的内在性质及规律，为进一步的数据分析提供基础。此类学习任务中研究最多、<font color="blue">应用最广的是“聚类”（clustering）</font></li>
<li>聚类试图将数据集中的样本划分为若干通常是不相交的子集，每个子集称为一个“簇”（cluster）。</li>
<li>聚类既能作为一个单独的过程，用于找寻数据内的分布结构，也可作为分类等其他学习任务的前驱过程。</li>
</ul>
<h4 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h4><ul>
<li>聚类性能度量亦称聚类“有效性指标”（validity index）<ul>
<li>与监督学习中的性能度量作用相似。对聚类结果，我们需通过<font color="blue">某种性能度量来评估其好坏</font>；</li>
<li>另一方面，若明确了最终将要使用的性能度量，则可直接将其作为聚类过程的优化目标，从而更好地得到符合要求的聚类结果。<br>聚类是将样本集D划分为若干不相交的子集，即样本簇。直观上看，我们希望“物以类聚”，<font color="blue">即同一簇的样本尽可能彼此相似，不同簇的样本尽可能不同</font>。换言之，聚类结果的“簇内相似度”（intra-cluster similarity）高且“簇间相似度”（inter-cluster similarity）低。</li>
</ul>
</li>
<li>聚类性能度量大致有两类：<ul>
<li>“外部指标”（external index）<br>将聚类结果与某个“参考模型”（reference model）进行比较；<ul>
<li>常用的聚类性能度量外部指标有：<ul>
<li>Jaccard系数（Jaccard Coefficient，简称 JC）</li>
<li>FM指数（Fowlkes and Mallows Index，简称FMI）</li>
<li>Rand指数（Rand Index，简称RI）</li>
</ul>
</li>
</ul>
</li>
<li>“内部指标”（internal index）<br>直接考察聚类结果而不利用任何参考模型<ul>
<li>常用的聚类性能度量内部指标有<ul>
<li>DB指数（Davies-Bouldin Index，简称DBI）</li>
<li>Dunn指数（Dunn Index，简称DI）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h4><ul>
<li>给定样本$x_i=（x_{i1}，x_{i2}；…；x_{in}），与x_j=（x_{j1}；x_{j2}；…；x_{jn}）$</li>
<li>最常用的是”闵可夫斯基距离“（Minkowski distance）<img src="/2018/08/20/ml/聚类/resources/37A273ABD2B1EC581982F7BBECCBE35A.jpg"></li>
<li>p=2时，闵可夫斯基距离即欧氏距离（Euclidean distance）<img src="/2018/08/20/ml/聚类/resources/E635A778006828C007A4DFF678BB32F7.jpg"></li>
<li>p=1时，闵可夫斯基距离即曼哈顿距离（Manhattan distance）<img src="/2018/08/20/ml/聚类/resources/78391F39AD86022E73BD024B2FF230C8.jpg">
</li>
</ul>
<h4 id="原型聚类"><a href="#原型聚类" class="headerlink" title="原型聚类"></a>原型聚类</h4><p>原型聚类亦称”<font color="blue">基于原型的聚类</font>“（prototype-based clustering），此类算法<font color="blue">假设聚类结构能通过一组原型刻画</font>，在现实聚类任务中极为常用。</p>
<ul>
<li>通常情形下，算法先对原型进行初始化，然后对原型进行迭代更新求解。<font color="blue">采用不同的原型表示、不同的求解方式，将产生不同的算法</font><ul>
<li><font color="purple">我的理解就是直接通过先假设几个样本就为几类簇，然后再迭代更新</font>

</li>
</ul>
</li>
</ul>
<ul>
<li>k均值算法<br>给定样本集$D={x_1，x_2，…，x_m}$，”k均值“（k-means）算法针对聚类所得簇划分$C={C_1，C_2，…，C_k}$最小化平方误差<ul>
<li>直观来看，上面式子在一定程度上刻画了簇内样本围绕簇均值向量的紧密程度，E值越小则簇内样本相似度越高<img src="/2018/08/20/ml/聚类/resources/E1734D53B25C4D0019F957BEAB0042B7.jpg">
<ul>
<li>其中$\mu_i$，是簇$C_i$的均值向量<img src="/2018/08/20/ml/聚类/resources/AE0804FF1B1322B4E95E28E786386EA3.jpg"></li>
</ul>
</li>
</ul>
</li>
<li><p>学习向量量化<br>与k均值算法类似，“学习向量量化”（Learning Vector Quantization，简称LVQ）也是试图找到一组原型向量来刻画聚类结构，但与一般的聚类算法不同的是，LVQ假设数据样本带有类别标记，学习过程用样本的这些监督信息来辅助聚类</p>
<ul>
<li>和KMeans的区别：<ul>
<li>LVQ数据样本带有标签 </li>
<li>初始化方式不同，LVQ是初始化一组向量，KMeans初始化几个簇点</li>
<li>迭代方式不同，LVQ是循环找到每个样本点和向量簇最近的向量，然后根据该样本点的类别是否和该向量表示的类别是否相同，另该向量靠近或更远离该点<img src="/2018/08/20/ml/聚类/resources/729572530662A9FC2EFCF920DF512324.jpg">
</li>
</ul>
</li>
</ul>
</li>
<li><p>高斯混合聚类<br>与k均值、LVQ用原型向量来刻画聚类结构不同，高斯混合（Mixture-of-Gaussian）聚类采用概率模型来表达聚类原型</p>
<ul>
<li>选择了高斯混合模型作为原型表示</li>
<li><a href="https://blog.csdn.net/lin_limin/article/details/81048411" target="_blank" rel="noopener">结合高斯混合模型理解</a></li>
</ul>
</li>
</ul>
<h4 id="密度聚类"><a href="#密度聚类" class="headerlink" title="密度聚类"></a>密度聚类</h4><p>密度聚类亦称“基于密度的聚类”（density-based clustering），此类算法<font color="blue">假设聚类结构能通过样本分布的紧密程度确定</font>。通常情况下，密度聚类算法从样本密度的角度来考察样本之间的可连接性，并基于可连接样本不断扩展聚类簇以获得最终的聚类结果。</p>
<ul>
<li>DBSCAN是一种著名的密度聚类算法</li>
</ul>
<h4 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h4><p>层次聚类（hierarchical clustering）<font color="blue">试图在不同层次对数据集进行划分，从而形成树形的聚类结构</font>。数据集的划分可采用“自底向上”的聚合策略，也可采用“自顶向下”的分拆策略。</p>
<ul>
<li>AGNES 是一种采用自底 向上聚合策略的层次聚类算法.它先将数据集中 的每个样本看作一个初始聚类簇，然后在算法运行的每一步中找 出距离最近的两个粟类簇进行合并，该过程不断重复，直至达到预设的聚类簇个数</li>
<li><a href="https://yuancl.github.io/2019/05/22/ml/层次聚类Louvain/" target="_blank" rel="noopener">Louvain算法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/06/ml/决策树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/06/ml/决策树/" itemprop="url">决策树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-06T08:10:21+08:00">
                2018-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/机器学习基础/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>决策树一般分为三步：特征划分，树生成，树剪枝</p>
<h3 id="基本概念-特征划分"><a href="#基本概念-特征划分" class="headerlink" title="基本概念(特征划分)"></a>基本概念(特征划分)</h3><h4 id="熵：表示随机变量的不确定性"><a href="#熵：表示随机变量的不确定性" class="headerlink" title="熵：表示随机变量的不确定性"></a>熵：表示随机变量的不确定性</h4><ul>
<li>X是一个取有限个值的离散随机变量，其概率分布为$P(X=x_i)=p_i, i=1,2,..,n$</li>
<li>熵定义为$H(X)=-\sum_{i=1}^np_ilogp_i$</li>
<li>又定义可知，熵只依赖于X的分布，而与X的取值无关</li>
</ul>
<h4 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h4><ul>
<li>条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y 的不确定性，也就是给定随机变量X的条件下Y的条件熵</li>
<li>定义为：$H(Y|X)=\sum_{i=1}^np_iH(Y|X=x_i)$</li>
</ul>
<h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><ul>
<li>表示得知特征X的信息而使得类Y的信息不确定性减少的程度</li>
<li>特征A对心里数据集D的信息增益定义为：$g(D,A)=H(D)-H(D|A)$<ul>
<li>个人理解为不确定性的减少量</li>
</ul>
</li>
</ul>
<h4 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h4><ul>
<li>以信息增益作为划分数据集的特征，存在偏向于选择取值较多的特征的问题</li>
<li>$g_R(D,A)=\frac{g(D,A)}{H_A(D)}$其中$H_A(D)=-\sum_{i=1}^{n}\frac{|D_i|}{D}log_2\frac{|D_i|}{D}$,n是特征A取值的个数</li>
</ul>
<h3 id="树生成"><a href="#树生成" class="headerlink" title="树生成"></a>树生成</h3><p>就是根据特征选择来区分</p>
<ul>
<li>ID3:使用的信息增益进行特征划分</li>
<li>C4.5:使用信息增益比进行特征的划分</li>
</ul>
<h3 id="树剪枝"><a href="#树剪枝" class="headerlink" title="树剪枝"></a>树剪枝</h3><ul>
<li>生成树一般按照局部最优原则生成，容易过拟合</li>
</ul>
<h4 id="剪枝（pruning）是决策树学习算法对付”过拟合“的主要手段。"><a href="#剪枝（pruning）是决策树学习算法对付”过拟合“的主要手段。" class="headerlink" title="剪枝（pruning）是决策树学习算法对付”过拟合“的主要手段。"></a>剪枝（pruning）是决策树学习算法对付”过拟合“的主要手段。</h4><h4 id="决策树剪枝的基本策略有”预剪枝“（prepruning）和”后剪枝“（post-pruning）"><a href="#决策树剪枝的基本策略有”预剪枝“（prepruning）和”后剪枝“（post-pruning）" class="headerlink" title="决策树剪枝的基本策略有”预剪枝“（prepruning）和”后剪枝“（post-pruning）"></a>决策树剪枝的基本策略有”预剪枝“（prepruning）和”后剪枝“（post-pruning）</h4><ul>
<li>预剪枝是指在决策树生成过程中，对每个节点在划分前进行估计，若当前的划分不能带来决策树泛化性能提升，则停止划分并将当前节点标记为叶节点</li>
<li>后剪枝是先从训练集生成一颗完整的决策树，然后自底向上的对非叶节点进行考察，若将该节点对应的子树替换为叶节点能带来决策树泛化性能提升，则将该子树替换为叶节点</li>
</ul>
<h4 id="剪枝处理降低了”过拟合“风险，但也带来了”欠拟合“的风险。"><a href="#剪枝处理降低了”过拟合“风险，但也带来了”欠拟合“的风险。" class="headerlink" title="剪枝处理降低了”过拟合“风险，但也带来了”欠拟合“的风险。"></a>剪枝处理降低了”过拟合“风险，但也带来了”欠拟合“的风险。</h4><ul>
<li>一般情形下，后剪枝决策树欠拟合风险较小，泛化性能往往优于预剪枝决策树</li>
<li>但后剪枝训练开销比未剪枝决策树和预剪枝决策树都要大很多</li>
</ul>
<h3 id="CART-classification-and-regression-tree-算法"><a href="#CART-classification-and-regression-tree-算法" class="headerlink" title="CART(classification and regression tree)算法"></a>CART(classification and regression tree)算法</h3><ul>
<li>CART是在给定输入随机变量X的条件下输出随机变量Y 的条件概率分布的学习方法，分类回归树即可以用于分类，也可以用于回归</li>
</ul>
<h4 id="CART决策树的生成"><a href="#CART决策树的生成" class="headerlink" title="CART决策树的生成"></a>CART决策树的生成</h4><ul>
<li>回归树：使用平方误差最小化的准则进行特征选择<ul>
<li>启发式方法(即随机选择第j个变量和它的取值进行划分),遍历特征和各个特征的取值</li>
</ul>
</li>
<li>分类树：使用基尼指数(Gini index)(和熵类似)<ul>
<li>假设有K个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为$Gini(p)=\sum_{k=1}^Kp_k(1-p_k)$</li>
<li>如果样本集合D根据特征A是否取某一可能值a被分割为$D_1和D_2$两部分，则在特征A的条件下，集合D的基尼指数定义为$Gini(D,A)=\frac{D_1}{D}Gini(D_1)+\frac{D_2}{D}Gini(D_2)$<ul>
<li>基尼指数Gini(D)表示集合D的不确定性</li>
<li>基尼指数Gini(D,A)表示经A=a分割后集合D的不确定性，基尼指数越大，样本集合的不确定性也就越大，这个和熵比类似</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="CART决策树的剪枝"><a href="#CART决策树的剪枝" class="headerlink" title="CART决策树的剪枝"></a>CART决策树的剪枝</h4><ul>
<li>用验证数据集对已生成的数进行剪枝并选择最优子树，这时是用的损失函数最小作为剪枝的标准</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="/2018/08/06/ml/决策树/resources/60FDDA878E668B64094D4FB11F9E1448.jpg">
<img src="/2018/08/06/ml/决策树/resources/0FAF75BC9C7ED3CE454648CC7CBA2A69.jpg">
<img src="/2018/08/06/ml/决策树/resources/07631FA8DBF39C5DCA3DC4283AE42665.jpg">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/30/ml/朴素贝叶斯法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/30/ml/朴素贝叶斯法/" itemprop="url">朴素贝叶斯法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T22:10:11+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/机器学习基础/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="朴素贝叶斯发学习与分类"><a href="#朴素贝叶斯发学习与分类" class="headerlink" title="朴素贝叶斯发学习与分类"></a>朴素贝叶斯发学习与分类</h4><ul>
<li>基本概念<ul>
<li>先验概率分布：$P(Y=c_k),k=1,2..K(c_1,c_2…为类分类标签)$</li>
<li>条件概率分布:$P(X=x|Y=c_k)$</li>
<li>贝叶斯定理：有了先验概率分布和条件概率分布，就能够得到联合概率分布$P(X,Y)=P(Y)P(X|Y)$</li>
<li>后验概率分布：$P(Y=c_k|X=x)$<ul>
<li>意义：对给定输入x，通过学习到的模型计算后延概率分布，将后验概率最大的类作为x的类输出</li>
</ul>
</li>
<li>所以基于贝叶斯定理的后验概率:$P(Y=c_k|X=x)=\frac {P(Y=c_k,X)}{P(X)}=\frac {P(Y=c_k)P(X|Y=c_k)}{P(X)}$</li>
<li>基于条件独立性假设的朴素贝叶斯法：<br>$P(X=x|Y=c_k)=P(X=x^{(1)},X=x^{(2)}…X=x^{(n)}|Y=c_k)=\prod_{j=1}^{n}P(X=x^{(j)})|Y=c_k$</li>
</ul>
</li>
</ul>
<h4 id="贝叶斯-amp-朴素贝叶斯法"><a href="#贝叶斯-amp-朴素贝叶斯法" class="headerlink" title="贝叶斯&amp;朴素贝叶斯法"></a>贝叶斯&amp;朴素贝叶斯法</h4><ul>
<li>背景：<ul>
<li>贝叶斯决策论（Bayesian decision theory）是概率框架下的基本方法。</li>
<li>假设有N种可能的类别标记，即$y={c_1，c_2，…，c_N}，λ_{ij}$是一个将真实标记为cj的样本误分类为ci产生的期望损失(expected loss），即在样本x上的“条件风险”（conditional rsik）<img src="/2018/07/30/ml/朴素贝叶斯法/resources/A105A2C12AE38198F1CE0D871BE252C9.jpg"></li>
</ul>
</li>
<li>任务：我们的任务是寻找一个判断准则，以最小化总体风险</li>
<li>解决方法：贝叶斯判断准则<ul>
<li>使用贝叶斯判定准则来最小化决策风险，首先要获得后验概率P(c|x)</li>
<li>然而，在现实任务中这通常难以直接获得。从这个角度来看，机器学习所要实现的是<font color="blue">基于有限的训练样本尽可能准确的估计出后验证概率P(c|x)</font>。大体来说主要有两种策略:<ul>
<li>判别式模型:给定x，可通过<font color="blue">直接建模P(y|x)来预测c</font></li>
<li><font color="blue">生成式模型</font>:先对联合概率分布P（x，c）建模，然后再由此获得P（y|x):<br>$P(Y=c_k|X=x)=\frac {P(Y=c_k,X)}{P(X)}=\frac {P(Y=c_k)P(X|Y=c_k)}{P(X)}$(贝叶斯公式)<ul>
<li>因为P(X)都是一样的，于是生成式转换为问题：$y=arg maxP(Y=c_k)P(X|Y=c_k)$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>朴素贝叶斯分类器<ul>
<li>基于贝叶斯公式来估计后验概率P(y|x)的主要困难在于:类条件概率P(x|y)是所有属性(x取值有多个)上的联合概率，难以从有限的训练样本直接估计而得。</li>
<li>为了避开这个障碍，朴素贝叶斯分类器（naive Bayes classifier）采用了“属性条件独立性假设”（attribute conditional independence assumption）<ul>
<li>即对已知类别，假设所有属性$(x^{(j)})$相互独立。换言之，假设每个属性独立地对分类结果发生影响。即$P(X=x|Y=c_k)=P(X=x^{(1)},X=x^{(2)}…X=x^{(n)}|Y=c_k)=\prod_{j=1}^{n}P(X=x^{(j)})|Y=c_k$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="朴素贝叶斯的参数估计-概率估计方法"><a href="#朴素贝叶斯的参数估计-概率估计方法" class="headerlink" title="朴素贝叶斯的参数估计(概率估计方法)"></a>朴素贝叶斯的参数估计(概率估计方法)</h4><p>在朴素贝叶斯法中，学习意味着估计$P(Y=c_k)和P(X=x^{(i)}|Y=c_k)$这里有多种方法进行估计：</p>
<ul>
<li>极大释然估计<ul>
<li>先验概率计算：<img src="/2018/07/30/ml/朴素贝叶斯法/resources/C083939637A97BD793D29ABC12B9FE40.jpg"></li>
<li>条件概率计算：<img src="/2018/07/30/ml/朴素贝叶斯法/resources/BD916F68806629CDA221C30B62F506F2.jpg"></li>
</ul>
</li>
<li>贝叶斯估计<br>上面的极大释然估计可能会出现要估计的概率值为0的情况，这时会影响到后验概率等的计算，使分类产生偏差贝叶斯估计会适当加一个极小系数$(\lambda)$来避免这种情况<ul>
<li>当$(\lambda)=0$时，就是极大释然估计</li>
<li>当$(\lambda)=1$时，称为拉普拉斯平滑<ul>
<li>先验概率计算：<img src="/2018/07/30/ml/朴素贝叶斯法/resources/13348C2F23C3022494A8788B1705679A.jpg"></li>
<li>条件概率计算：<img src="/2018/07/30/ml/朴素贝叶斯法/resources/2D7929519A50DE30D0D713F588AD868D.jpg">
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><img src="/2018/07/30/ml/朴素贝叶斯法/resources/1420A554D1A7BA334371478A04ADB586.jpg">
<img src="/2018/07/30/ml/朴素贝叶斯法/resources/67F1479ECCC9C40C08DE4D02D509F3E6.jpg">

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/27/ml/GBDT模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/27/ml/GBDT模型/" itemprop="url">GBDT模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T07:19:11+08:00">
                2018-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/集成学习/" itemprop="url" rel="index">
                    <span itemprop="name">集成学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://yuancl.github.io/2018/07/24/ml/集成学习方法/" target="_blank" rel="noopener">集成学习方法</a></p>
<h4 id="GB-Gradient-Boosting-理解"><a href="#GB-Gradient-Boosting-理解" class="headerlink" title="GB(Gradient Boosting)理解"></a>GB(Gradient Boosting)理解</h4><ul>
<li><p>理解梯度下降</p>
<ul>
<li>求解目标函数$J(\theta)$的最优解，本质上是一轮一轮的求解w</li>
<li>对于最终的最后解W*,是由初始值$w_0$经过M次迭代得到的</li>
</ul>
</li>
<li><p>对比理解多轮迭代后的GB函数最优解</p>
<ul>
<li>$f(x)$经过M次迭代，得到$F(x)=\sum_{i=1}^m\theta _if_i(x)$</li>
<li>这里是反向思考：因为梯度下降是通过梯度下降的方法求出w参数值，最后就是经过了M轮迭代求出最优解w<em>.  这里的w是参数，同样的思想对比到函数F(x)上,<font color="blue">将F(x)视为整体类似于w</font>，最后通过多轮迭代求出F</em>(x)最优解</li>
<li>梯度增强的作者们意识到，如果使用“梯度下降”（Gradient Descent）来优化一个目标函数，最后的预测式可以写成一个加和的形式。也就是，每一轮梯度的值和一个叫“学习速率”（Learning Rate）的参数共同叠加起来形成了最后的预测结果。这个观察非常重要，如果把这个观察和我们的目标，也就是构造弱学习器的加权平均联系起来看，我们就会发现，<font color="blue">其实每个梯度的值就可以认为是一个弱学习器，而学习速率就可以看作是某种意义上的权重</font></li>
<li>每一轮迭代，我们把当前所有学习器的加权平均结果当作这一轮的函数值，然后求得针对某一个损失函数对于当前所有学习器的参数的一个梯度。<strong>然后，我们利用某一个弱学习器算法，可以是线性回归模型（Linear Regression）、对数几率模型（Logistic Regression）等来拟合这个梯度</strong>。<strong>最后，我们利用“线查找”（Line Search）的方式找到权重</strong>。<ul>
<li>说得更直白一些，<font color="red">那就是我们尝试利用一些简单的模型来拟合不同迭代轮数的梯度</font></li>
<li>梯度增强的一个特点就是梯度下降本身带来的，那就是每一轮迭代一定是去拟合比上一轮小的一个梯度，函数对目标的整体拟合也是越来越好的。这其实也就是增强算法和梯度下降的一个完美结合</li>
</ul>
</li>
</ul>
</li>
<li><p>可以看出上述是一个求解梯度的过程，因此也称为基于梯度的Boost方法(即GB:Gradient Boosting)</p>
</li>
<li><p>算法</p>
<ul>
<li>这里的m是m个机器学习模型，n应该是样本的数量。这里就能够看出，boost方法就是前一轮的结果会影响后一轮<img src="/2018/07/27/ml/GBDT模型/resources/297ED5E7B40AD7E5192DB0EE79E577F7.jpg"></li>
<li>一般定义不同的Loss函数，就能得到不同的算法，比如这里用二分类任务中常用的$L(y,F)=log(1+exp(-2yF)), y \in {(-1,1)}$,就能得到如下算法：<img src="/2018/07/27/ml/GBDT模型/resources/DB082CA541217CF13A4A4DC535C9D2F0.jpg">
</li>
</ul>
</li>
</ul>
<h4 id="DT理解"><a href="#DT理解" class="headerlink" title="DT理解"></a>DT理解</h4><p>参考<a href="https://yuancl.github.io/2018/08/06/ml/决策树/" target="_blank" rel="noopener">决策树</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/24/ml/集成学习方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/24/ml/集成学习方法/" itemprop="url">集成学习方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-24T23:09:10+08:00">
                2018-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/集成学习/" itemprop="url" rel="index">
                    <span itemprop="name">集成学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="个体与集成"><a href="#个体与集成" class="headerlink" title="个体与集成"></a>个体与集成</h4><p>集成学习（ensemble learning）的一般结构：先产生一组“个体学习器”（individual learner），再用某种策略将他们结合起来<br><img src="/2018/07/24/ml/集成学习方法/resources/4B0EDAB496C74765B1C89797A91E5BB2.jpg"></p>
<ul>
<li><p>集成也可包含不同类型的个体学习器</p>
<ul>
<li>在一般的经验中，如果把好坏不等的东西掺到一起，那么通常结果会是比坏的好一些，比好的要坏一些。集成学习把多个学习器结合起来，如何能获得比最好的单一学习器更好的性能呢</li>
</ul>
</li>
<li><p>考虑一个简单的例子：在二分类任务中，假定三个分类器在三个测试样本的表现如下图所示</p>
<ul>
<li>集成学习的结果通过投票法（voting）产生，即“少数服从多数”。</li>
<li>这个简单的例子显示出：要获得好的集成，个体学习器应“好而不同”。<ul>
<li>个体学习器要有一定的<font color="blue">“准确性”</font>，即学习器不能太坏</li>
<li>而且要有<font color="blue">“多样性”（diversity）</font>，即学习器之间有差异。</li>
<li>事实上，如何产生并结合“好而不同”的个体学习器，恰是集成学习研究的核心<img src="/2018/07/24/ml/集成学习方法/resources/EC147BED87BB6C5FE7B43608C8F250F2.jpg">
</li>
</ul>
</li>
</ul>
</li>
<li><p>多学习器结合的好处</p>
<ul>
<li>从统计的方面看，由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到同等性能，此时若使用单学习器可能因误选而导致泛化性能不佳，结合多个学习器减小这一风险；</li>
<li>从计算的方面来看，学习算法往往会陷入局部极小，有的局部极小点所对应的泛化性能可能很糟，而通过多次运行之后进行结合，可降低陷入糟糕局部极小点的风险；</li>
<li>从表示的方面来看，某些但学习器则肯定无效，而通过结合多个学习器，由于响应的假设空间有所扩大，有可能学得更好的近似<img src="/2018/07/24/ml/集成学习方法/resources/C648EEAAFD8FB8DF3F291B6B0A998214.jpg">
</li>
</ul>
</li>
<li><p>结合不同子模型的分类</p>
<img src="/2018/07/24/ml/集成学习方法/resources/BC8AEFE15619E77CB8F6BF1C2478097F.jpg">
</li>
</ul>
<h4 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h4><p>各个子模型训练的时候是随机在样本库中抽取部分样本，并行训练，最后的多个模型参数取平均值</p>
<ul>
<li>随机抽取样本(有放回的)</li>
<li>并行训练模型，各个模型之间无影响</li>
<li>最后样本合成时，以平均值参数进行合成$F(x)=\frac 1m\sum_{i=1}^mf_i(x)$<img src="/2018/07/24/ml/集成学习方法/resources/2C16474FB5F7CE8CDAFFAFA3A1E57777.jpg">
</li>
</ul>
<h4 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h4><p>Boosting是一族可将弱学习器提升为强学习器的算法。这族算法的工作机制类似：</p>
<ul>
<li>先从初始训练集训练出一个基学习器，再根据基学习器的表现对<font color="blue">训练样本分布进行调整</font>，使得先前基学习器做错的训练样本在后续收到更多的关注<font color="blue">(其实就是改变权重，对判断正确的样本进行降权，判断错误的进行加权)</font></li>
<li>然后基于调整后的样本分布来训练下一个基学习器；</li>
<li>如此重复进行，直到基学习器数目<font color="blue">达到事先指定的值T</font>，最终将这T个学习器进行加权结合<br>特点：</li>
<li>每个学习区直接相互影响，串行化学习，最终的模型是对各个学习器加权求和,$F(x)=\sum_{i=1}^m\theta _if_i(x)$<img src="/2018/07/24/ml/集成学习方法/resources/E593F3A40EE6A8026D8ECB26C37FA5D2.jpg"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/22/ml/概率图/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/22/ml/概率图/" itemprop="url">概率图模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T22:19:00+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/机器学习基础/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考文章：<br><a href="https://www.jiqizhixin.com/articles/2017-11-29-3?from=synced&amp;keyword=概率图" target="_blank" rel="noopener">机器之心：读懂概率图</a></p>
<h4 id="图模型"><a href="#图模型" class="headerlink" title="图模型"></a>图模型</h4><ul>
<li>图模型为很多存在依赖关系的真实世界任务提供了可以解释的建模方式。图模型为我们提供了一种用有原则的方式解决这些任务的方法</li>
<li>概率图模型（PGM/probabilistic graphical model）是一种用于学习这些带有依赖（dependency）的模型的强大框架</li>
<li><p>图的每个节点（node）都关联了一个随机变量，而图的边（edge）则被用于编码这些随机变量之间的关系</p>
<ul>
<li>我们可以将图的模式分为两大类——贝叶斯网络（Bayesian network）和马尔可夫网络（Markov networks）<img src="/2018/07/22/ml/概率图/resources/5682C7A9FF3D94CD38864DBCE005C4AD.jpg">
</li>
</ul>
</li>
<li><p>“生成式”（generative）模型考虑联合分布P(Y,R,O)；<br>“判别式”（discriminative）模型考虑条件分布P(Y,R|O);</p>
</li>
<li><p>条件独立</p>
<ul>
<li>图结构实际上带有关于这些变量的重要信息。具体来说，它们定义了这些变量之间的一组条件独立（conditional independence），也就是这种形式的陈述——「如果观察到 A，那么 B 独立于 C。」</li>
</ul>
</li>
</ul>
<h4 id="有向图模型-贝叶斯网络"><a href="#有向图模型-贝叶斯网络" class="headerlink" title="有向图模型:贝叶斯网络"></a>有向图模型:贝叶斯网络</h4><p>“生成式”（generative）模型考虑联合分布P(Y,R,O),属于生成模型，借助有向无环图(DAG图)来刻画属性简的依赖关系，并<font color="blue">使用条件概率表来描述属性的联合概率分布</font>，这里重点是<font color="blue">计算联合概率分布</font></p>
<ul>
<li>例子<ul>
<li>让我们看看与每个节点关联的表格，它们的正式名称是条件概率分布（CPD/conditional probability distribution）<img src="/2018/07/22/ml/概率图/resources/D40035339F71FF67D1772BC364EC9F28.jpg">
</li>
</ul>
</li>
</ul>
<h4 id="隐马可科夫模型"><a href="#隐马可科夫模型" class="headerlink" title="隐马可科夫模型"></a>隐马可科夫模型</h4><p>隐马尔可夫模型（Hidden Markov Model，简称HMM）是结构最简单的动态贝叶斯网（dynamic Bayesian network），这是一种著名的有向图模型，主要用于时序数据建模，在语音识别、自然语言处理等领域有广泛应用</p>
<ul>
<li><p>其中几个重要的参数：</p>
<ul>
<li>a.状态转移概率，y1,y2….的转移概率。</li>
<li>b.输出观察概率y输出x的概率。</li>
<li>c.初始状态概率，y1<img src="/2018/07/22/ml/概率图/resources/7CFCA82225375CBBA196AB941002CB04.jpg">
</li>
</ul>
</li>
<li><p>HMM解决的问题</p>
<ul>
<li><font color="blue">如何评估模型与观测序列之间的匹配程度</font>，例如许多任务已有观察序列{x1,x2,x3…xn-1}求x(n)的最有可能值，就是转换为判定模型，<font color="blue">$P(x|\theta)$最大的匹配程度</font></li>
<li><font color="blue">根据观测序列推断出隐藏的模型状态</font>，已经{x1,x2,x3…x(n)},求{y1,y2,y3…y(n)}。如语音识别中，观测值为语音符号，隐藏状态为文字</li>
<li><font color="blue">如何训练模型，使其能最好的描述观测数据</font>，即调整模型参数[A,B,PI]，使得该观测序列出现的概率最大</li>
</ul>
</li>
</ul>
<h4 id="马尔可夫随机场"><a href="#马尔可夫随机场" class="headerlink" title="马尔可夫随机场"></a>马尔可夫随机场</h4><p>马尔科夫随机场是典型的马尔科夫网络，是一种著名的无向图模型，<font color="blue">多个变量之间的联合概率分布能够基于团分解为多个因子的乘积</font><br><img src="/2018/07/22/ml/概率图/resources/EEF542AE63098C2BA0D95E6D555110C2.jpg"></p>
<ul>
<li><p>团：<br>对于图中的任意两点都有线相连，则称该结点子集为一个”团”，若在一个团中加入另外的节点都不再形成团，那么陈该该结点子集为”极大团”</p>
</li>
<li><p>势函数：<br>亦称”因子”(factor)，这是定义在变量子集上的非负实函数，主要用于定义概率分布函数:</p>
</li>
<li><p>多个变量之间的联合概率分布能够基于团分解为多个因子的乘积</p>
<img src="/2018/07/22/ml/概率图/resources/E6DCEA98E35EF5CA0D9991847B6F7698.jpg">
<img src="/2018/07/22/ml/概率图/resources/DE12D0B50F145E19B33337D1C43F0839.jpg">
</li>
</ul>
<h4 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h4><p>是一种判别式无向图模型，对条件分布进行建模。试图对多个变量在给定观测值后的条件概率进行建模。</p>
<ul>
<li>具体说就是给定$X={x_1,x_2,x_3,….x_n}和Y={y_1,y_2,y_3…y_n}$然后建立模型P(Y|X)。然后对后面给定的$(x_{11},x_{12},x….)$直接使用P(Y|X)模型进行预测。标记变量y可以是结构型变量，即其分量直接具有某种相关性</li>
</ul>
<h4 id="学习和推断"><a href="#学习和推断" class="headerlink" title="学习和推断"></a>学习和推断</h4><ul>
<li><p>学习(参数估计)：<br>如果都知道各个变量，各个属性间的依赖关系，只需要对各个条件概率表进行计数，就能够得到联合概率分布。但实际情况中几乎不会轻易得到所有的关系依赖，所有贝叶斯网络的首要任务是根据训练数据<font color="blue">找出最“恰当”的贝叶斯网，也就是学习出属性间的依赖关系，得到联合概率分布</font>。使用的是评分函数算法</p>
</li>
<li><p>推断(推理)：通过第一步的学习得到了联合概率分布，属性，变量间的依赖关系，也就是<font color="blue">得到了贝叶斯网络后，就可以通过它来回答”查询”，及通过一些已知属性变量的观测值来预测一些其他的属性</font></p>
<ul>
<li><p>我们可以使用推理来解答一些问题:</p>
<ul>
<li>边际推理（marginal inference）：寻找一个特定变量的概率分布。比如，给定一个带有变量 A、B、C 和 D 的图，其中 A 取值 1、2 和 3，求 p(A=1)、p(A=2) 和 p(A=3)。</li>
<li>后验推理（posterior inference）：给定某些显变量 v_E（E 表示证据（evidence）），其取值为 e，求某些隐藏变量 v_H 的后验分布 p(v_H|v_E=e)。</li>
<li>最大后验（MAP）推理（maximum-a-posteriori inference）：给定某些显变量 v_E，其取值为 e，求使其它变量 v_H 有最高概率的配置</li>
</ul>
</li>
<li><p>解答这些问题的流行的算法<br>其中既有精准的算法，也有近似的算法。所有这些算法都既可用于贝叶斯网络，也可用于马尔可夫网络</p>
<ul>
<li>精确推断方法<br>希望能计算出目标变量的边际分布或条件分布的精确值。遗憾的是，一般情形下，此类算法的计算复杂度随着极大团规模的增长呈指数增长，适用范围有限<ul>
<li>变量消去<br>精确推断的实质是一类动态规划算法，它利用图模型所描述的条件独立性来消减计算目标概率值所需的计算量。变量消去是最直观的精确推断算法，也是构建其他精确推断算法的基础。<br>变量消去法有一个明显的缺陷：若需计算多个边际分布，重复使用变量消去法将对造成大量的冗余计算。</li>
<li>信念传播<br>信念传播（Belief Propagation）算法将变量消去法中的求和操作看作一个消息传递过程，较好的解决了求解多个边际分布时重复计算问题。</li>
</ul>
</li>
<li>近似推断方法<br>希望在较低时间复杂度下获得原问题的近似解。此类方法在现实任务中更常用<ul>
<li>采样：通过使用随机化方法完成近似<ul>
<li>MCMC采样:概率图模型中最常用的采用技术是马尔可夫链蒙特卡罗（Markov Chain Monte Carlo，简称MCMC）方法</li>
</ul>
</li>
<li>变分推断（variational inference）<ul>
<li>变分推断通过使用已知简单分布来逼近所需推断的复杂分布，并通过限制近似分布的类型，从而得到一种局部最优、但具有确定解的近似后验分布</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h4><ul>
<li><p><strong>三门问题(贝叶斯网络)</strong></p>
<ul>
<li>问题描述：<br>主持人会向你展示三扇关着的门，其中一扇门之后有一辆车，其它门后则有一些无价值的东西。你可以选择一扇门。然后，主持人会打开剩下的两扇门中没有车的一扇。现在，你可以选择是否更换选择的门：坚持你之前选择的那扇门，还是选择主持人剩下的那扇关闭的门。你会更换吗？<ul>
<li>直觉上看，主持人似乎并没有透露任何信息。事实证明这种直觉并不完全正确。让我们使用我们的新工具「图模型」来理解这个问题<img src="/2018/07/22/ml/概率图/resources/5BA177BF6F0E9415D2B19622C743CCAA.jpg"></li>
</ul>
</li>
<li>网络构造<ul>
<li>定义变量<ul>
<li>D：背后有车的门</li>
<li>F：你的第一个选择</li>
<li>H：主持人打开的门</li>
<li>I：F 是否是 D？</li>
</ul>
</li>
<li>D、F 和 H 可取值为 1、2 或 3；I 可取值 0 或 1。D 和 I 是未被观察到的，而 F 是已观察到的。在主持人打开其中一扇门之前，H 都是未被观察到的。因此，我们使用贝叶斯网络来解决我们的问题<img src="/2018/07/22/ml/概率图/resources/D4BFDA14C753F0039371D80EB0098B09.jpg"></li>
</ul>
</li>
<li>计算逻辑<br>注意箭头的方向——D 和 F 是相互独立的，I 显然依赖于 D 和 F，主持人选择的门也取决于 D 和 F。目前你对 D 还一无所知。（这与学生网络的结构类似，即知道学生的智力水平不能让你获得有关课程难度的任何信息<ul>
<li>现在，主持人选择了门 H 并打开了它。所以现在 H 已被观察到<img src="/2018/07/22/ml/概率图/resources/70032238A7BF5A48B7CDBF44977207A1.jpg"></li>
<li>然后下面就是通过计算变量的CPD来得到最大的条件概率(判别式模型),详情见<a href="https://www.jiqizhixin.com/articles/2017-11-29-3?from=synced&amp;keyword=概率图" target="_blank" rel="noopener">机器之心：读懂概率图</a></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>图像去噪</strong></p>
<ul>
<li><p>真实图像和噪音图像</p>
<img src="/2018/07/22/ml/概率图/resources/B79299EA90F5B96C7A44B9BCDA990893.jpg">
<img src="/2018/07/22/ml/概率图/resources/CAA3F15B2AB83ECFE01B7DB0EF10CB36.jpg">
</li>
<li><p>目标：现在你的目标是恢复原始图像。让我们看看如何使用概率图模型来实现</p>
</li>
<li><p>思考步骤</p>
<ul>
<li>首先第一步是思考哪些变量是观察得到的，哪些变量不能观察到，以及<font color="blue">我们可以如何将它们连接起来构成一个图</font></li>
<li>让我们将有噪声图像中的每个像素都<font color="blue">定义为一个观察到的随机变量</font>，并将基准图像中的每个像素都<font color="blue">定义为一个未被观察到的变量</font>。由此，如果该图像的大小为 MxN，那么观察到的变量和未被观察到的变量都各有 MN 个。让我们将观察到的变量表示为 X_ij，未被观察到的变量定义为 Y_ij。每个变量都可取值 +1 或 -1（分别对应于黑色像素和白色像素）。<ul>
<li>模型：给定观察到的变量，我们希望找到未观察到的变量的最有可能的值。这<font color="red">对应于 MAP 推理</font></li>
</ul>
</li>
<li><p>现在让我们使用一些领域知识来构建图结构。很显然，在有噪声图像中的 (i,j) 位置观察到的变量取决于在基准图像中的 (i,j) 位置未观察到的变量。原因是大多数时候它们是相等的。</p>
</li>
<li><p>我们还能得到什么信息？对于基准图像，邻近的像素通常有一样的值——在颜色变化的边界不是这样，但在每个单一颜色的区域内有这个性质。因此，<font color="blue">如果 Y_ij 和 Y_kl 是邻近像素，那么我们将它们连接起来</font></p>
</li>
</ul>
</li>
<li><p>图结构</p>
<ul>
<li>其中，白色节点表示未被观察到的变量 Y_ij，灰色节点表示观察到的变量 X_ij。每个 X_ij 都连接到对应的 Y_ij，每个 Y_ij 都连接到它的相邻节点。</li>
<li>注意<font color="blue">这是一个马尔可夫网络</font>，因为图像的像素之间不存在因果关系，因此这里不适合使用贝叶斯网络中有方向的箭头<img src="/2018/07/22/ml/概率图/resources/2DA40217C2D320AA8E7CCF137F62E066.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/15/ml/KNN(K近邻)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/15/ml/KNN(K近邻)/" itemprop="url">KNN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-15T07:09:09+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/机器学习基础/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>选取离样本最近的K个点</p>
<ul>
<li>计算距离的方式可以有多种，欧氏距离等等</li>
</ul>
</li>
<li><p>分类策略</p>
<ul>
<li>比较简单的就是直接看这K个点钟类别最多的一个，来作为当前样本点的类别</li>
</ul>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>K近邻不用进行训练</li>
<li>选择K个点的时候，每次都需要计算全部的样本，计算量比较大</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
	
      	    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/10/ml/KMeans/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雷哥">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雷哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/ml/KMeans/" itemprop="url">KMeans</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T21:09:02+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/机器学习基础/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h4><ul>
<li>随机选择K个簇中心点$\mu_1,\mu_2,\mu_3…\mu_k$</li>
<li>然后依次加入其它节点，采用距离最近(该节点到各簇中心距离)的判别方式</li>
<li>重新计算各簇中心点(因为有新节点加入)，直到所有节点都已加入<img src="/2018/07/10/ml/KMeans/resources/B02EB1114F53182AC4C8A33C041F5A71.jpg">
</li>
</ul>
<h4 id="Random-initialization"><a href="#Random-initialization" class="headerlink" title="Random initialization"></a>Random initialization</h4><ul>
<li>会重复KMeans n次，找出cost最小的k值<img src="/2018/07/10/ml/KMeans/resources/D1E2FCC1B588D77F14AA8C949B1A487E.jpg">
<img src="/2018/07/10/ml/KMeans/resources/32DA03A8B43321EEE51CE601BF8B214B.jpg">
<h4 id="Cost-funciton"><a href="#Cost-funciton" class="headerlink" title="Cost funciton"></a>Cost funciton</h4>所有点到各簇中心点距离和<img src="/2018/07/10/ml/KMeans/resources/BC93652FCD6FE37D162DE72468A473F6.jpg"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


	
    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/favicon.ico" alt="雷哥">
          <p class="site-author-name" itemprop="name">雷哥</p>
           
              <p class="site-description motion-element" itemprop="description">不积跬步无以至千里</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">77</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yuancl" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-雷哥"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雷哥</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
